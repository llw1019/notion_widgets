<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Chalkboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --outer-bg: #ffffff;
      --card-bg: #ffffff;
      --card-border: rgba(28, 33, 42, 0.08);
      --text-strong: #1c212a;
      --text-muted: #6b7280;
      --accent: #ff7a18;
      --accent-dark: #d95b00;
      --shadow-soft: 0 6px 14px rgba(15, 23, 42, 0.16);
      --panel-bg: rgba(245, 247, 250, 0.9);
      --danger: #f87171;
    }

    [data-theme="dark"] {
      --outer-bg: rgb(25, 25, 25);
      --card-bg: rgba(15, 18, 28, 0.92);
      --card-border: rgba(255, 255, 255, 0.06);
      --text-strong: #f4f5f7;
      --text-muted: #a4afbd;
      --accent: #ffa95c;
      --accent-dark: #ff7c1f;
      --shadow-soft: 0 12px 22px rgba(0, 0, 0, 0.45);
      --panel-bg: rgba(19, 23, 33, 0.85);
      --danger: #fb7185;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Space Grotesk', 'Noto Sans TC', sans-serif;
      background: var(--outer-bg);
      color: var(--text-strong);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 28px 12px;
    }

    .board-card {
      width: min(860px, 100%);
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 18px;
      padding: 22px;
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .control-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }

    .board-stage {
      background: var(--panel-bg);
      border-radius: 16px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      position: relative;
    }

    canvas {
      width: 100%;
      max-width: 800px;
      height: auto;
      display: block;
      margin: 0 auto;
      background: #2d3b2f;
      border-radius: 12px;
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.45);
      cursor: none;
    }

    #brush-indicator {
      position: absolute;
      top: 0;
      left: 0;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.8);
      pointer-events: none;
      transform: translate(-50%, -50%);
      opacity: 0;
      transition: opacity 0.12s ease;
      mix-blend-mode: screen;
    }

    #brush-indicator[data-mode="eraser"] {
      border-style: dashed;
      border-color: rgba(255, 255, 255, 0.6);
      background: transparent;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 11px 16px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button.primary {
      background: linear-gradient(120deg, var(--accent), var(--accent-dark));
      color: #fff;
      box-shadow: 0 12px 20px rgba(255, 122, 24, 0.25);
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.8);
      color: var(--text-strong);
      border: 1px solid rgba(28, 33, 42, 0.1);
    }

    [data-theme="dark"] button.secondary {
      background: rgba(18, 22, 30, 0.85);
      color: var(--text-muted);
      border-color: rgba(255, 255, 255, 0.08);
    }

    button.danger {
      background: var(--danger);
      color: #fff;
      box-shadow: 0 12px 18px rgba(248, 113, 113, 0.35);
    }

    button:not(:disabled):hover {
      transform: translateY(-2px);
    }

    .slider-label {
      font-size: 0.8rem;
      color: var(--text-muted);
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1;
    }

    .slider-label-heading {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .slider-value {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-strong);
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.1);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      cursor: pointer;
    }

    .status-line {
      font-size: 0.85rem;
      color: var(--text-muted);
      min-height: 20px;
    }

    @media (max-width: 560px) {
      body {
        padding: 18px 10px;
      }

      .board-card {
        padding: 18px;
      }

      .control-bar {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="board-card">
    <div class="control-bar">
      <div class="control-group">
        <button class="secondary" id="toggleButton">Switch to Eraser</button>
        <label class="slider-label">
          <span class="slider-label-heading">
            <span>Brush Thickness</span>
            <span id="brush-size-display" class="slider-value">5 px</span>
          </span>
          <input type="range" id="thickness" min="1" max="50" value="5">
        </label>
      </div>
      <button class="danger" id="clearButton">Clear Canvas</button>
    </div>
    <div class="board-stage">
      <canvas id="chalkboard" width="800" height="600"></canvas>
      <div id="brush-indicator" data-mode="chalk"></div>
    </div>
    <p class="status-line" id="board-status">畫布會每秒自動儲存一次。</p>
  </div>

  <script>
    const systemThemeQuery = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;

    document.addEventListener('DOMContentLoaded', () => {
      setThemeFromLocalStorage();
      watchSystemTheme();
      const canvas = document.getElementById('chalkboard');
      const ctx = canvas.getContext('2d');
      const toggleButton = document.getElementById('toggleButton');
      const thicknessSlider = document.getElementById('thickness');
      const clearButton = document.getElementById('clearButton');
      const statusLine = document.getElementById('board-status');
      const boardStage = document.querySelector('.board-stage');
      const brushIndicator = document.getElementById('brush-indicator');
      const brushSizeDisplay = document.getElementById('brush-size-display');

      const state = {
        drawing: false,
        isChalk: true,
        chalkThickness: 5,
        eraserThickness: 20,
        saveTimer: null
      };

      function setChalkStyle() {
        ctx.lineWidth = state.chalkThickness;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
        updateBrushIndicatorSize();
      }

      function setEraserStyle() {
        ctx.lineWidth = state.eraserThickness;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#2d3b2f';
        updateBrushIndicatorSize();
      }

      function startDrawing(event) {
        state.drawing = true;
        ctx.beginPath();
        const { x, y } = pointerPosition(event);
        ctx.moveTo(x, y);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      function stopDrawing() {
        state.drawing = false;
        ctx.beginPath();
      }

      function draw(event) {
        updateBrushIndicatorFromEvent(event);
        if (!state.drawing) return;
        const { x, y } = pointerPosition(event);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.moveTo(x, y);
      }

      function pointerPosition(event) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (event.clientX - rect.left) * scaleX,
          y: (event.clientY - rect.top) * scaleY
        };
      }

      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        localStorage.removeItem('chalkboardData');
        updateStatus('畫布已清除。');
      }

      function updateStatus(message) {
        statusLine.textContent = message;
      }

      function updateBrushSizeDisplay(value) {
        if (!brushSizeDisplay) return;
        brushSizeDisplay.textContent = `${value} px`;
      }

      function updateBrushIndicatorSize() {
        if (!brushIndicator) return;
        const rect = canvas.getBoundingClientRect();
        const scale = rect.width && canvas.width ? rect.width / canvas.width : 1;
        const baseSize = state.isChalk ? state.chalkThickness : state.eraserThickness;
        const displaySize = Math.max(2, baseSize * scale);
        brushIndicator.style.width = `${displaySize}px`;
        brushIndicator.style.height = `${displaySize}px`;
        brushIndicator.dataset.mode = state.isChalk ? 'chalk' : 'eraser';
      }

      function updateBrushIndicatorFromEvent(event) {
        if (!brushIndicator || !boardStage) return;
        const stageRect = boardStage.getBoundingClientRect();
        const x = event.clientX - stageRect.left;
        const y = event.clientY - stageRect.top;
        brushIndicator.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
        brushIndicator.style.opacity = 1;
      }

      function hideBrushIndicator() {
        if (brushIndicator) brushIndicator.style.opacity = 0;
      }

      thicknessSlider.addEventListener('input', (event) => {
        const value = Number(event.target.value);
        if (state.isChalk) {
          state.chalkThickness = value;
          ctx.lineWidth = state.chalkThickness;
        } else {
          state.eraserThickness = value;
          ctx.lineWidth = state.eraserThickness;
        }
        updateBrushIndicatorSize();
        updateBrushSizeDisplay(value);
      });

      toggleButton.addEventListener('click', () => {
        state.isChalk = !state.isChalk;
        if (state.isChalk) {
          setChalkStyle();
          toggleButton.textContent = 'Switch to Eraser';
          thicknessSlider.value = state.chalkThickness;
          updateBrushSizeDisplay(state.chalkThickness);
        } else {
          setEraserStyle();
          toggleButton.textContent = 'Switch to Chalk';
          thicknessSlider.value = state.eraserThickness;
          updateBrushSizeDisplay(state.eraserThickness);
        }
      });

      clearButton.addEventListener('click', clearCanvas);

      canvas.addEventListener('mousedown', (event) => {
        updateBrushIndicatorFromEvent(event);
        startDrawing(event);
      });
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseenter', (event) => {
        updateBrushIndicatorFromEvent(event);
      });
      canvas.addEventListener('mouseleave', () => {
        stopDrawing();
        hideBrushIndicator();
      });

      window.addEventListener('resize', updateBrushIndicatorSize);

      function loadDrawing() {
        const savedData = localStorage.getItem('chalkboardData');
        if (savedData) {
          const img = new Image();
          img.src = savedData;
          img.onload = () => ctx.drawImage(img, 0, 0);
        }
      }

      function saveDrawing() {
        const data = canvas.toDataURL();
        localStorage.setItem('chalkboardData', data);
        updateStatus('已自動儲存。');
      }

      function startAutoSave() {
        if (state.saveTimer) clearInterval(state.saveTimer);
        state.saveTimer = setInterval(saveDrawing, 1000);
      }

      setChalkStyle();
      thicknessSlider.value = state.chalkThickness;
      updateBrushSizeDisplay(state.chalkThickness);
      updateBrushIndicatorSize();
      loadDrawing();
      startAutoSave();
      updateStatus('畫布會每秒自動儲存一次。');
    });

    window.addEventListener('storage', (event) => {
      if (event.key === 'mode') {
        setThemeFromLocalStorage();
      }
    });

    function setThemeFromLocalStorage() {
      const storedTheme = localStorage.getItem('mode');
      const prefersDark = systemThemeQuery ? systemThemeQuery.matches : false;
      const useDark = storedTheme ? storedTheme === 'dark' : prefersDark;
      applyTheme(useDark);
    }

    function applyTheme(useDark) {
      document.documentElement.dataset.theme = useDark ? 'dark' : 'light';
    }

    function watchSystemTheme() {
      if (!systemThemeQuery) return;
      systemThemeQuery.addEventListener('change', (event) => {
        if (!localStorage.getItem('mode')) {
          applyTheme(event.matches);
        }
      });
    }
  </script>
</body>
</html>
