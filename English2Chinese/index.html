<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Flashcards</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --page-bg: #f5f6f8;
            --card-bg: #ffffff;
            --card-border: rgba(28, 33, 42, 0.08);
            --text-strong: #1c212a;
            --text-muted: #6b7280;
            --accent: #ff7a18;
            --accent-dark: #d95b00;
            --shadow-soft: 0 10px 22px rgba(15, 23, 42, 0.15);
            --panel-bg: rgba(245, 247, 250, 0.9);
        }

        [data-theme="dark"] {
            --page-bg: #0f1219;
            --card-bg: rgba(15, 18, 28, 0.92);
            --card-border: rgba(255, 255, 255, 0.06);
            --text-strong: #f4f5f7;
            --text-muted: #a4afbd;
            --accent: #ffa95c;
            --accent-dark: #ff7c1f;
            --shadow-soft: 0 18px 32px rgba(0, 0, 0, 0.55);
            --panel-bg: rgba(19, 23, 33, 0.85);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Space Grotesk', 'Noto Sans TC', sans-serif;
            background: var(--page-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
            color: var(--text-strong);
        }

        .app-shell {
            width: min(420px, 100%);
            display: flex;
            flex-direction: column;
            gap: 12px;
            animation: floatIn 0.45s ease;
        }

        .card {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 16px;
            padding: 18px;
            box-shadow: var(--shadow-soft);
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .input-stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-stack input {
            width: 100%;
            border-radius: 10px;
            border: 1.5px solid var(--card-border);
            padding: 12px 14px;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-strong);
            background: rgba(255, 255, 255, 0.92);
        }

        [data-theme="dark"] .input-stack input {
            background: rgba(24, 28, 40, 0.92);
        }

        .input-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 8px;
        }

        button {
            border: none;
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button.primary {
            background: linear-gradient(120deg, var(--accent), var(--accent-dark));
            color: #fff;
            box-shadow: 0 12px 20px rgba(255, 122, 24, 0.25);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.75);
            color: var(--text-strong);
            border: 1px solid transparent;
        }

        [data-theme="dark"] button.secondary {
            background: rgba(18, 22, 30, 0.75);
            border-color: rgba(255, 255, 255, 0.05);
            color: var(--text-muted);
        }

        button:disabled {
            opacity: 0.65;
            cursor: not-allowed;
        }

        button:not(:disabled):hover {
            transform: translateY(-2px);
        }

        .status-line {
            min-height: 20px;
            font-size: 0.8rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-line.loading::before {
            content: '';
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-top-color: var(--accent);
            animation: spin 0.8s linear infinite;
        }

        .translation-panel {
            background: var(--panel-bg);
            border-radius: 14px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 120px;
        }

        .word-headline {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: baseline;
        }

        .word-headline .word-main {
            font-size: 1.4rem;
            font-weight: 600;
        }

        .pronunciation {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .translation-block {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        [data-theme="dark"] .translation-block {
            background: rgba(11, 15, 23, 0.75);
        }

        .pos {
            font-weight: 600;
            font-size: 0.8rem;
            letter-spacing: 0.08em;
            color: var(--accent);
        }

        .translation {
            font-size: 1rem;
        }

        .definition {
            font-style: italic;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .example {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .empty-state {
            text-align: center;
            color: var(--text-muted);
        }

        .secondary-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 8px;
        }

        .api-form {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 14px;
            display: none;
            flex-direction: column;
            gap: 8px;
        }

        [data-theme="dark"] .api-form {
            background: rgba(12, 16, 24, 0.85);
        }

        .api-form input {
            border-radius: 8px;
            border: 1px solid var(--card-border);
            padding: 10px;
            font-size: 0.85rem;
            background: rgba(255, 255, 255, 0.85);
        }

        [data-theme="dark"] .api-form input {
            background: rgba(18, 22, 30, 0.85);
            color: var(--text-strong);
        }

        .api-form small {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 640px) {
            body {
                padding: 8px;
            }

            .card {
                padding: 16px;
                border-radius: 14px;
            }

            .translation-panel {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="app-shell">
        <main class="card" id="card">
            <div class="input-stack">
                <label class="sr-only" for="english-word-input">English word</label>
                <input type="text" id="english-word-input" placeholder="輸入或按下抽單字" autocomplete="off">
                <div class="input-actions">
                    <button id="random-word-button" class="primary">抽單字</button>
                    <button id="refresh-word-button" class="secondary">重新翻譯</button>
                </div>
            </div>

            <p class="status-line" id="status-line"></p>

            <section id="chinese-translation" class="translation-panel">
                <p class="empty-state">按下「抽單字」開始學習。</p>
            </section>

            <div class="secondary-actions">
                <button id="copy-button" class="secondary">複製結果</button>
                <button id="speak-button" class="secondary">播放語音</button>
            </div>

            <div id="api-key-form" class="api-form">
                <label for="api-key-input">Gemini API Key</label>
                <input type="text" id="api-key-input" placeholder="輸入您的 Gemini API Key">
                <button id="api-key-button" class="primary">保存 API Key</button>
                <small id="api-key-hint">加入 API Key 以取得更完整的翻譯內容。</small>
                <small id="api-key-error" style="display:none; color:#b3261e;">無效的 API Key，請再試一次。</small>
            </div>
        </main>
    </div>

    <script>
        const GEMINI_STORAGE_KEY = 'Gemini_apiKey';
        const DEFAULT_WORDS = ['apple', 'run', 'beautiful'];
        const POS_CANONICAL_MAP = {
            adjective: 'adj', adj: 'adj', 'adj.': 'adj', '形容詞': 'adj', '形容词': 'adj',
            noun: 'n', n: 'n', 'n.': 'n', '名詞': 'n', '名词': 'n',
            verb: 'v', v: 'v', 'v.': 'v', '動詞': 'v', '动词': 'v',
            adverb: 'adv', adv: 'adv', 'adv.': 'adv', '副詞': 'adv', '副词': 'adv',
            pronoun: 'pron', pron: 'pron', 'pron.': 'pron', '代名詞': 'pron', '代词': 'pron',
            preposition: 'prep', prep: 'prep', 'prep.': 'prep', '介系詞': 'prep', '介词': 'prep',
            conjunction: 'conj', conj: 'conj', 'conj.': 'conj', '連接詞': 'conj', '连词': 'conj',
            interjection: 'interj', interj: 'interj', 'interj.': 'interj', '感嘆詞': 'interj', '感叹词': 'interj',
            article: 'art', art: 'art', '冠詞': 'art', '冠词': 'art',
            determiner: 'det', det: 'det', '限定詞': 'det', '限定词': 'det',
            auxiliary: 'aux', 'auxiliary verb': 'aux', aux: 'aux', '助動詞': 'aux', '助动词': 'aux',
            numeral: 'num', num: 'num', '數詞': 'num', '数词': 'num',
            modal: 'modal', '情態動詞': 'modal', '情态动词': 'modal',
            phrase: 'phr', phr: 'phr', '片語': 'phr', '片语': 'phr'
        };
        const POS_DISPLAY_MAP = {
            adj: 'adj.',
            n: 'n.',
            v: 'v.',
            adv: 'adv.',
            pron: 'pron.',
            prep: 'prep.',
            conj: 'conj.',
            interj: 'interj.',
            art: 'art.',
            det: 'det.',
            aux: 'aux.',
            num: 'num.',
            phr: 'phr.',
            modal: 'modal'
        };
        const POS_SPOKEN_MAP = {
            adj: 'adjective',
            n: 'noun',
            v: 'verb',
            adv: 'adverb',
            pron: 'pronoun',
            prep: 'preposition',
            conj: 'conjunction',
            interj: 'interjection',
            art: 'article',
            det: 'determiner',
            aux: 'auxiliary verb',
            num: 'numeral',
            phr: 'phrase',
            modal: 'modal verb',
            general: ''
        };

        const state = {
            words: [],
            queue: [],
            currentWord: '',
            isSpeaking: false,
            activeUtterance: null,
            speechCancelled: false
        };

        document.addEventListener('DOMContentLoaded', async () => {
            setThemeFromLocalStorage();

            await prepareWordList();
            initializeWordQueues();
            bindEvents();

            try {
                await checkAndSetApiKey();
            } catch (error) {
                console.error('Init error:', error);
            }
        });

        function setThemeFromLocalStorage() {
            const storedTheme = localStorage.getItem('mode');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const useDarkTheme = storedTheme ? storedTheme === 'dark' : prefersDark;
            document.documentElement.dataset.theme = useDarkTheme ? 'dark' : 'light';
        }

        async function checkAndSetApiKey() {
            const apiKey = getApiKey({ silent: true });
            toggleApiKeyForm(!apiKey);
            await fetchAndUpdateVocabulary(state.currentWord || null);
        }

        function bindEvents() {
            const input = document.getElementById('english-word-input');
            const randomBtn = document.getElementById('random-word-button');
            const refreshBtn = document.getElementById('refresh-word-button');
            const copyBtn = document.getElementById('copy-button');
            const speakBtn = document.getElementById('speak-button');
            const apiKeyBtn = document.getElementById('api-key-button');

            input.addEventListener('keyup', (event) => {
                if (event.key === 'Enter') {
                    fetchAndUpdateVocabulary(event.target.value, { forceRefresh: true });
                }
            });

            randomBtn.addEventListener('click', () => fetchAndUpdateVocabulary(null, { random: true }));

            refreshBtn.addEventListener('click', () => {
                if (state.currentWord) {
                    fetchAndUpdateVocabulary(state.currentWord, { forceRefresh: true });
                }
            });

            copyBtn.addEventListener('click', handleCopyResult);
            speakBtn.addEventListener('click', handleSpeakResult);
            apiKeyBtn.addEventListener('click', handleApiKeySave);
        }

        async function prepareWordList() {
            try {
                const response = await fetch('words.json');
                if (!response.ok) throw new Error('無法載入單字庫');
                state.words = await response.json();
            } catch (error) {
                console.error('Word list error:', error);
            }
            if (!state.words.length) {
                state.words = [...DEFAULT_WORDS];
            }
        }

        function refillQueue() {
            if (!state.words.length) return;
            state.queue = shuffle([...state.words]);
        }

        function initializeWordQueues() {
            if (!state.words.length) {
                state.words = [...DEFAULT_WORDS];
            }
            refillQueue();
        }

        async function fetchAndUpdateVocabulary(word = null, options = {}) {
            const englishInput = document.getElementById('english-word-input');
            const shouldRandomize = options.random === true;
            const inputValue = englishInput.value.trim();
            const providedWord = typeof word === 'string' ? word.trim() : '';

            let resolvedWord = '';
            if (shouldRandomize) {
                resolvedWord = fetchRandomWord() || '';
            } else if (providedWord) {
                resolvedWord = providedWord;
            } else if (inputValue) {
                resolvedWord = inputValue;
            } else {
                resolvedWord = fetchRandomWord() || '';
            }

            if (!resolvedWord) {
                setStatus('error', '沒有可查詢的單字，請稍後再試。');
                return;
            }

            englishInput.value = resolvedWord;
            state.currentWord = resolvedWord;
            setStatus('loading', `查詢 "${resolvedWord}" 中...`);
            toggleLoading(true);

            const apiKey = getApiKey({ silent: true });
            if (!apiKey) {
                updateTranslationUI(null);
                setStatus('error', '請先設定 Gemini API Key 以查詢單字');
                toggleApiKeyForm(true);
                toggleLoading(false);
                return;
            }

            try {
                const details = await fetchWordDetails(apiKey, resolvedWord, options);
                updateTranslationUI(details);
                setStatus('success', '完成');
            } catch (error) {
                console.error(error);
                updateTranslationUI(null);
                setStatus('error', error.message || '查詢失敗');
                toggleApiKeyForm(true);
            } finally {
                toggleLoading(false);
            }
        }

        function updateTranslationUI(details) {
            const panel = document.getElementById('chinese-translation');
            panel.innerHTML = '';

            if (!details) {
                panel.innerHTML = '<p class="empty-state">暫時找不到翻譯，請換一個單字或稍後再試。</p>';
                return;
            }

            const header = document.createElement('div');
            header.className = 'word-headline';

            const wordEl = document.createElement('span');
            wordEl.className = 'word-main';
            wordEl.textContent = details.word || state.currentWord;

            const pronEl = document.createElement('span');
            pronEl.className = 'pronunciation';
            pronEl.textContent = formatPronunciationText(details.pronunciation || '');

            header.appendChild(wordEl);
            if (pronEl.textContent) {
                header.appendChild(pronEl);
            }
            panel.appendChild(header);

            const translations = details.translation || {};
            const definitions = details.definition || {};
            const examples = details.exampleSentence || details.example_sentence || {};

            const parts = Object.keys(translations);
            if (!parts.length) {
                const empty = document.createElement('p');
                empty.className = 'empty-state';
                empty.textContent = '這個單字暫時沒有可用的翻譯。';
                panel.appendChild(empty);
                return;
            }

            parts.forEach((pos) => {
                const block = document.createElement('article');
                block.className = 'translation-block';

                const posEl = document.createElement('div');
                posEl.className = 'pos';
                posEl.textContent = formatPosLabel(pos);

                const translationEl = document.createElement('div');
                translationEl.className = 'translation';
                translationEl.textContent = cleanTranslation(translations[pos]);

                block.appendChild(posEl);
                block.appendChild(translationEl);

                if (definitions[pos]) {
                    const defEl = document.createElement('div');
                    defEl.className = 'definition';
                    defEl.textContent = definitions[pos];
                    block.appendChild(defEl);
                }

                if (examples[pos]) {
                    const exampleEl = document.createElement('div');
                    exampleEl.className = 'example';
                    exampleEl.textContent = examples[pos];
                    block.appendChild(exampleEl);
                }

                panel.appendChild(block);
            });
        }

        function setStatus(stateName, message) {
            const statusLine = document.getElementById('status-line');
            statusLine.className = `status-line ${stateName === 'loading' ? 'loading' : ''}`;
            statusLine.textContent = message;
        }

        function toggleLoading(isLoading) {
            document.getElementById('random-word-button').disabled = isLoading;
            document.getElementById('refresh-word-button').disabled = isLoading;
        }

        function handleCopyResult() {
            const panelText = document.getElementById('chinese-translation').innerText.trim();
            if (!panelText) return;

            if (!navigator.clipboard) {
                setStatus('error', '此瀏覽器不支援剪貼簿 API');
                return;
            }

            navigator.clipboard.writeText(`${state.currentWord}\n${panelText}`)
                .then(() => setStatus('success', '已複製到剪貼簿'))
                .catch(() => setStatus('error', '無法使用剪貼簿，請手動複製。'));
        }

        function handleSpeakResult() {
            if (!('speechSynthesis' in window)) {
                setStatus('error', '此瀏覽器不支援語音播放');
                return;
            }

            const panel = document.getElementById('chinese-translation');
            if (!panel) return;

            if (state.isSpeaking) {
                state.speechCancelled = true;
                window.speechSynthesis.cancel();
                resetSpeechState({ preserveCancellation: true });
                setStatus('success', '已停止語音');
                return;
            }

            const blocks = Array.from(panel.querySelectorAll('.translation-block'));
            let bodyText = '';

            if (blocks.length) {
                const segments = blocks
                    .map((block) => {
                        const posText = block.querySelector('.pos')?.textContent || '';
                        const translationText = block.querySelector('.translation')?.textContent || '';
                        const definitionText = block.querySelector('.definition')?.textContent || '';
                        const exampleText = block.querySelector('.example')?.textContent || '';

                        const spokenParts = [];
                        const spokenPos = getSpokenPosLabel(posText);
                        if (spokenPos) spokenParts.push(spokenPos);
                        if (translationText) spokenParts.push(translationText);
                        if (definitionText) spokenParts.push(`Definition: ${definitionText}`);
                        if (exampleText) spokenParts.push(`Example: ${exampleText}`);

                        return spokenParts.join('. ').replace(/\s+/g, ' ').trim();
                    })
                    .filter(Boolean);
                bodyText = segments.join(' ');
            } else {
                const panelText = panel.innerText || '';
                const pronunciationText = panel.querySelector('.pronunciation')?.textContent || '';
                bodyText = pronunciationText ? panelText.replace(pronunciationText, '').trim() : panelText.trim();
            }

            const spokenContent = [state.currentWord, bodyText].filter(Boolean).join('. ');
            const finalText = spokenContent || state.currentWord || '';
            if (!finalText) {
                setStatus('error', '沒有可播放的內容');
                return;
            }

            const utterance = new SpeechSynthesisUtterance(finalText);
            utterance.lang = 'en-US';
            utterance.onend = () => {
                const wasCancelled = state.speechCancelled;
                resetSpeechState();
                if (!wasCancelled) {
                    setStatus('success', '語音播放完成');
                }
            };
            utterance.onerror = () => {
                const wasCancelled = state.speechCancelled;
                resetSpeechState();
                if (wasCancelled) {
                    setStatus('success', '已停止語音');
                    return;
                }
                setStatus('error', '語音播放失敗');
            };

            window.speechSynthesis.cancel();
            state.isSpeaking = true;
            state.activeUtterance = utterance;
            state.speechCancelled = false;
            updateSpeakButtonState(true);
            setStatus('success', '播放語音中');
            window.speechSynthesis.speak(utterance);
        }

        function toggleApiKeyForm(visible) {
            const form = document.getElementById('api-key-form');
            form.style.display = visible ? 'flex' : 'none';
        }

        async function handleApiKeySave() {
            const apiKeyInput = document.getElementById('api-key-input');
            const apiKeyError = document.getElementById('api-key-error');
            apiKeyError.style.display = 'none';

            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                apiKeyError.style.display = 'block';
                return;
            }

            const isValid = await validateApiKey(apiKey);
            if (isValid) {
                localStorage.setItem(GEMINI_STORAGE_KEY, apiKey);
                toggleApiKeyForm(false);
                await fetchAndUpdateVocabulary(state.currentWord || null, { forceRefresh: true });
            } else {
                apiKeyError.style.display = 'block';
            }
        }

        async function validateApiKey(apiKey) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: "Reply with 'ok'" }] }]
                    })
                });
                return response.ok;
            } catch (error) {
                console.error('API Key validation error:', error);
                return false;
            }
        }

        function fetchRandomWord() {
            if (!state.queue.length) {
                refillQueue();
            }
            return state.queue.pop() || DEFAULT_WORDS[Math.floor(Math.random() * DEFAULT_WORDS.length)];
        }

        async function fetchWordDetails(apiKey, word, options = {}) {
            if (!apiKey) {
                throw new Error('請先設定 Gemini API Key');
            }

            const prompt = `請以 JSON 回覆以下資訊，單字為 "${word}"：\n` +
                '1. translation 欄位：不同詞性的繁體中文翻譯\n' +
                '2. pronunciation 欄位：IPA，並以 / 開頭與結尾，例如 "/ˈæpəl/"\n' +
                '3. definition 與 example_sentence：請用英文撰寫\n' +
                '4. 詞性鍵請使用英文縮寫 (n., adj., v., adv., pron., prep., conj., interj., phr., 等)\n' +
                'JSON 格式: {"word":"","pronunciation":"","translation":{"pos":"中文"},"definition":{"pos":"English definition"},"example_sentence":{"pos":"English sentence"}}';

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }]
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || '翻譯服務暫時無法使用');
            }

            const data = await response.json();
            const rawText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
            if (!rawText) {
                throw new Error('模型未傳回資料');
            }

            const cleaned = rawText.replace(/```json|```/g, '').trim();
            let parsed;
            try {
                parsed = JSON.parse(cleaned);
            } catch (error) {
                console.error('JSON parse error:', error, cleaned);
                throw new Error('模型回傳格式錯誤');
            }

            return normalizeModelResponse(parsed, word);
        }

        function getApiKey({ silent = false } = {}) {
            const apiKey = localStorage.getItem(GEMINI_STORAGE_KEY);
            if (!apiKey && !silent) {
                toggleApiKeyForm(true);
                throw new Error('Gemini API Key 缺失');
            }
            if (!apiKey) {
                toggleApiKeyForm(true);
            }
            return apiKey;
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i -= 1) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function cleanTranslation(text = '') {
            return text.replace(/\s*\(.*?\)/g, '').trim();
        }

        function normalizeModelResponse(payload, fallbackWord) {
            const entries = Array.isArray(payload) ? payload : [payload];
            const normalized = {
                word: fallbackWord,
                pronunciation: '',
                translation: {},
                definition: {},
                exampleSentence: {}
            };

            entries.forEach((entry) => {
                if (!entry || typeof entry !== 'object') return;
                if (entry.word) normalized.word = entry.word;
                if (!normalized.pronunciation && entry.pronunciation) {
                    normalized.pronunciation = formatPronunciationText(entry.pronunciation);
                }

                mergeSectionByPos(normalized.translation, entry.translation);
                mergeSectionByPos(normalized.definition, entry.definition);
                mergeSectionByPos(normalized.exampleSentence, entry.example_sentence || entry.exampleSentence);
            });

            if (!Object.keys(normalized.translation).length && entries[0] && typeof entries[0].translation === 'string') {
                normalized.translation.general = entries[0].translation;
            }

            return normalized;
        }

        function mergeSectionByPos(target, source) {
            if (!source) return;
            if (typeof source === 'string') {
                target.general = source;
                return;
            }
            Object.entries(source).forEach(([pos, value]) => {
                if (!value) return;
                const key = canonicalizePos(pos);
                target[key] = value;
            });
        }

        function canonicalizePos(pos = '') {
            const cleaned = pos.trim().toLowerCase().replace(/\.$/, '');
            return POS_CANONICAL_MAP[cleaned] || cleaned || 'general';
        }

        function formatPosLabel(pos = '') {
            const key = canonicalizePos(pos);
            return POS_DISPLAY_MAP[key] || pos || '—';
        }

        function formatPronunciationText(text = '') {
            if (!text) return '';
            let cleaned = text.replace(/^[\[\(]+|[\]\)]+$/g, '').trim();
            cleaned = cleaned.replace(/\s+/g, ' ');
            if (!cleaned) return '';
            if (!cleaned.startsWith('/')) {
                cleaned = `/${cleaned}`;
            }
            if (!cleaned.endsWith('/')) {
                cleaned = `${cleaned}/`;
            }
            return cleaned;
        }

        function getSpokenPosLabel(posText = '') {
            const key = canonicalizePos(posText);
            const spoken = POS_SPOKEN_MAP[key];
            if (spoken) {
                return spoken;
            }
            return posText.replace(/\./g, '').trim();
        }

        function resetSpeechState({ preserveCancellation = false } = {}) {
            state.isSpeaking = false;
            state.activeUtterance = null;
            if (!preserveCancellation) {
                state.speechCancelled = false;
            }
            updateSpeakButtonState(false);
        }

        function updateSpeakButtonState(isSpeaking) {
            const speakBtn = document.getElementById('speak-button');
            if (!speakBtn) return;
            speakBtn.textContent = isSpeaking ? '停止語音' : '播放語音';
        }
    </script>
</body>
</html>